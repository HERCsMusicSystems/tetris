<!--
///////////////////////////////////////////////////////////////////////////////////
//                     Copyright (C) 2018 Dr Robert P. Wolf                      //
//                                                                               //
// Permission is hereby granted, free of charge, to any person obtaining a copy  //
// of this software and associated documentation files (the "Software"), to deal //
// in the Software without restriction, including without limitation the rights  //
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     //
// copies of the Software, and to permit persons to whom the Software is         //
// furnished to do so, subject to the following conditions:                      //
//                                                                               //
// The above copyright notice and this permission notice shall be included in    //
// all copies or substantial portions of the Software.                           //
//                                                                               //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, //
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN     //
// THE SOFTWARE.                                                                 //
///////////////////////////////////////////////////////////////////////////////////

-->

<html>

<head>
	<title>TETRIS 3D</title>
</head>

<body bgcolor=black style = "margin: 0;" >
	<div>
		<canvas id=tetris />
	</div>
</body>

<script>

var vtm = function (vector, matrix) {
	var v = [];
	for (var y = 0; y < matrix . length; y++) {
		var vv = 0;
		for (var x = 0; x < vector . length; x++) {
			vv += vector [x] * matrix [y] [x];
		}
		v . push (vv);
	}
	return v;
};

var mtm = function (m1, m2) {
	var m = [];
	for (var y = 0; y < m2 . length; y++) {
		var mm = []; m . push (mm);
		for (var x = 0; x < m1 . length; x++) {
			var value = 0.0;
			for (var i = 0; i < m2 . length; i++) {
				value += m1 [i] [x] * m2 [y] [i];
			}
			mm . push (value);
		}
	}
	return m;
};

var rollz = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[cosine, - sine, 0, 0], [sine, cosine, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], m);
};

var rollx = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[1, 0, 0, 0], [0, cosine, - sine, 0], [0, sine, cosine, 0], [0, 0, 0, 1]], m);
};

var rolly = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[cosine, 0, - sine, 0], [0, 1, 0, 0], [sine, 0, cosine, 0], [0, 0, 0, 1]], m);
};

var translate = function (m, x, y, z) {return mtm ([[1, 0, 0, x], [0, 1, 0, y], [0, 0, 1, z], [0, 0, 0, 1]], m);};

var context3d = function (canvas) {
	var ctx = canvas . getContext ('2d');
	ctx . screen = 600.0;
	ctx . rollz = function (angle) {
		var sine = Math . sin (angle), cosine = Math . cos (angle);
		var m = [[cosine, - sine, 0, 0], [sine, cosine, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
		ctx . matrix = mtm (m, ctx . matrix);
	};
	ctx . scale = function (scale) {
		var m = [[scale, 0, 0, 0], [0, scale, 0, 0], [0, 0, scale, 0], [0, 0, 0, 1]];
		ctx . matrix = mtm (ctx . matrix, m);
	};
	ctx . moveto = function (x, y, z) {
		var v = vtm ([x, y, z, 1], ctx . matrix);
		var scz = ctx . screen / (ctx . screen + v [2]);
		ctx . moveTo (v [0] * scz, v [1] * scz);
	};
	ctx . lineto = function (x, y, z) {
		var v = vtm ([x, y, z, 1], ctx . matrix);
		var scz = ctx . screen / (ctx . screen + v [2]);
		ctx . lineTo (v [0] * scz, v [1] * scz);
	};
	ctx . unity = function () {return [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];}
	ctx . reset_transform = function () {ctx . matrix = ctx . unity ();}
	ctx . reset_transform ();
	return ctx;
};

var canvas = document . getElementById ('tetris');
var ctx = context3d (canvas);

var Well = function () {
	this . dimensions = {width: 7, height: 7, depth: 12, side: 40};
	this . colours = ['blue', 'red', 'magenta', 'green', 'cyan', 'yellow', 'white', 'orange', 'blue', 'red', 'magenta', 'red', 'yellow', 'cyan'];
	this . content = [];
	this . initialiseContent = function () {
		this . content = [];
		for (var z = 0; z < this . dimensions . depth; z++) {
			var layer = []; this . content . push (layer);
			for (var x = 0; x < this . dimensions . width; x++) {
				var column = []; layer . push (column);
				for (var y = 0; y < this . dimensions . height; y++) {
					column . push (false);
				}
			}
		}
	};
	this . initialiseContent ();
	this . insertRandomBlock = function () {
		this . content [Math . floor (this . dimensions . depth * Math . random ())]
						[Math . floor (this . dimensions . width * Math . random ())]
						[Math . floor (this . dimensions . height * Math . random ())] = true;
	};
	for (var ind = 0; ind < 4; ind++) this . insertRandomBlock ();
	this . reSide = function (width, height) {
		this . dimensions . side = Math . min (width / this . dimensions . width * 0.96, height / this . dimensions . height * 0.96);
	};
	this . drawWell = function (ctx) {
		ctx . beginPath ();
		var right = this . dimensions . width * 0.5 * this . dimensions . side, left = - right;
		var bottom = this . dimensions . height * 0.5 * this . dimensions . side, top = - bottom;
		var depth = this . dimensions . depth * this . dimensions . side;
		for (var y = 1; y < this . dimensions . height; y++) {
			var yy = top + this . dimensions . side * y;
			ctx . moveto (left, yy, 0); ctx . lineto (left, yy, depth); ctx . lineto (right, yy, depth); ctx . lineto (right, yy, 0);
		}
		for (var x = 1; x < this . dimensions . width; x++) {
			var xx = left + this . dimensions . side * x;
			ctx . moveto (xx, top, 0); ctx . lineto (xx, top, depth); ctx . lineto (xx, bottom, depth); ctx . lineto (xx, bottom, 0);
		}
		for (var z = 0; z <= this . dimensions . depth; z++) {
			var zz = this . dimensions . side * z;
			ctx . moveto (left, top, zz); ctx . lineto (right, top, zz); ctx . lineto (right, bottom, zz); ctx . lineto (left, bottom, zz); ctx . lineto (left, top, zz);
		}
		ctx . moveto (left, top, 0); ctx . lineto (left, top, depth);
		ctx . moveto (right, top, 0); ctx . lineto (right, top, depth);
		ctx . moveto (right, bottom, 0); ctx . lineto (right, bottom, depth);
		ctx . moveto (left, bottom, 0); ctx . lineto (left, bottom, depth);
		ctx . stroke ();
	};
	this . drawContent = function (ctx) {
		var side = this . dimensions . side;
		var left = -0.5 * this . dimensions . width * side;
		var top = -0.5 * this . dimensions . height * side;
		for (var layer = this . dimensions . depth - 1; layer >= 0; layer--) {
			ctx . fillStyle = this . colours [layer];
			var depth = layer * side;
			for (var x = 0; x < this . dimensions . width; x++) {
				for (var y = 0; y < this . dimensions . height; y++) {
					if (this . content [layer] [x] [y]) {
						var a = left + side * x, b = a + side, c = top + side * y, d = c + side, dd = depth + side;
						ctx . beginPath ();
						ctx . moveto (a, c, depth), ctx . lineto (b, c, depth); ctx . lineto (b, d, depth); ctx . lineto (a, d, depth), ctx . closePath ();
						ctx . fill ();
						ctx . stroke ();
						if (y > this . dimensions . height * 0.5) {
							ctx . beginPath ();
							ctx . moveto (a, c, depth), ctx . lineto (a, c, dd); ctx . lineto (b, c, dd); ctx . lineto (b, c, depth);
							ctx . fill ();
						}
						if (y + 1 < this . dimensions . height * 0.5) {
							ctx . beginPath ();
							ctx . moveto (b, d, depth), ctx . lineto (b, d, dd); ctx . lineto (a, d, dd); ctx . lineto (a, d, depth);
							ctx . fill ();
						}
						if (x > this . dimensions . width * 0.5) {
							ctx . beginPath ();
							ctx . moveto (a, c, depth), ctx . lineto (a, c, dd); ctx . lineto (a, d, dd); ctx . lineto (a, d, depth);
							ctx . fill ();
						}
						if (x + 1 < this . dimensions . width * 0.5) {
							ctx . beginPath ();
							ctx . moveto (b, c, depth), ctx . lineto (b, c, dd); ctx . lineto (b, d, dd); ctx . lineto (b, d, depth);
							ctx . fill ();
						}
					}
				}
			}
		}
	};
	this . draw = function (ctx, width, height) {
		ctx . clearRect (0, 0, width, height);
		ctx . strokeStyle = '#44ff44';
		ctx . resetTransform ();
		ctx . lineWidth = 1;
		ctx . translate (width * 0.5, height * 0.5);
		this . drawWell (ctx);
		this . drawContent (ctx);
	}
};

var well = new Well ();

var resize = function () {
	canvas . width = window . innerWidth;
	canvas . height = window . innerHeight;
	well . reSide (window . innerWidth, window . innerHeight);
	well . draw (ctx, window . innerWidth, window . innerHeight);
};

//setInterval (resize, 50);
resize ();

</script>


</html>

