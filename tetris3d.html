<!--
///////////////////////////////////////////////////////////////////////////////////
//                     Copyright (C) 2018 Dr Robert P. Wolf                      //
//                                                                               //
// Permission is hereby granted, free of charge, to any person obtaining a copy  //
// of this software and associated documentation files (the "Software"), to deal //
// in the Software without restriction, including without limitation the rights  //
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     //
// copies of the Software, and to permit persons to whom the Software is         //
// furnished to do so, subject to the following conditions:                      //
//                                                                               //
// The above copyright notice and this permission notice shall be included in    //
// all copies or substantial portions of the Software.                           //
//                                                                               //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, //
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN     //
// THE SOFTWARE.                                                                 //
///////////////////////////////////////////////////////////////////////////////////

-->

<html>

<head>
	<title>TETRIS 3D</title>
</head>

<body bgcolor=black style = "margin: 0;" onkeypress="javascript: ctrl (event);" >
	<div>
		<canvas id=tetris />
	</div>
</body>

<script>

var vtm = function (vector, matrix) {
	var v = [];
	for (var y = 0; y < matrix . length; y++) {
		var vv = 0;
		for (var x = 0; x < vector . length; x++) {
			vv += vector [x] * matrix [y] [x];
		}
		v . push (vv);
	}
	return v;
};

var mtm = function (m1, m2) {
	var m = [];
	for (var y = 0; y < m2 . length; y++) {
		var mm = []; m . push (mm);
		for (var x = 0; x < m1 . length; x++) {
			var value = 0.0;
			for (var i = 0; i < m2 . length; i++) {
				value += m1 [i] [x] * m2 [y] [i];
			}
			mm . push (value);
		}
	}
	return m;
};

var rollz = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[cosine, - sine, 0, 0], [sine, cosine, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], m);
};

var rollx = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[1, 0, 0, 0], [0, cosine, - sine, 0], [0, sine, cosine, 0], [0, 0, 0, 1]], m);
};

var rolly = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[cosine, 0, - sine, 0], [0, 1, 0, 0], [sine, 0, cosine, 0], [0, 0, 0, 1]], m);
};

var translate = function (m, x, y, z) {return mtm ([[1, 0, 0, x], [0, 1, 0, y], [0, 0, 1, z], [0, 0, 0, 1]], m);};

var context3d = function (canvas) {
	var ctx = canvas . getContext ('2d');
	ctx . screen = 600.0;
	ctx . rollz = function (angle) {
		var sine = Math . sin (angle), cosine = Math . cos (angle);
		var m = [[cosine, - sine, 0, 0], [sine, cosine, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
		ctx . matrix = mtm (m, ctx . matrix);
	};
	ctx . scale = function (scale) {
		var m = [[scale, 0, 0, 0], [0, scale, 0, 0], [0, 0, scale, 0], [0, 0, 0, 1]];
		ctx . matrix = mtm (ctx . matrix, m);
	};
	ctx . moveto = function (x, y, z) {
		var v = vtm ([x, y, z, 1], ctx . matrix);
		var scz = ctx . screen / (ctx . screen + v [2]);
		ctx . moveTo (v [0] * scz, v [1] * scz);
	};
	ctx . lineto = function (x, y, z) {
		var v = vtm ([x, y, z, 1], ctx . matrix);
		var scz = ctx . screen / (ctx . screen + v [2]);
		ctx . lineTo (v [0] * scz, v [1] * scz);
	};
	ctx . unity = function () {return [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];}
	ctx . reset_transform = function () {ctx . matrix = ctx . unity ();}
	ctx . reset_transform ();
	return ctx;
};

var canvas = document . getElementById ('tetris');
var ctx = context3d (canvas);

var angle = 0;

var Block = function () {
	this . location = {x: 1, y: 1, z: 1};
	this . rotation = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
	this . block = [[[false, false, false], [false, true, false], [false, false, false]],
					[[true, false, false], [true, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . rotate_block = function () {
		var block = [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]];
		for (var layer = 0; layer < 3; layer++) {
			for (var row = 0; row < 3; row++) {
				for (var el = 0; el < 3; el++) {
					var v = vtm ([el - 1, row - 1, layer - 1, 1], this . rotation);
					block [v [2] + 1] [v [1] + 1] [v [0] + 1] = this . block [layer] [row] [el];
				}
			}
		}
		return block;
	};
	this . clamp_right = function (dimensions, block) {
		if (this . location . x + 2 > dimensions . height) {
			for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [y] [2]) {this . location . x = dimensions . width - 2; return;}}}
		}
		if (this . location . x + 1 > dimensions . height) {
			for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [y] [1]) {this . location . x = dimensions . width - 1; return;}}}
		}
		if (this . location . x > dimensions . height) this . location . x = dimensions . width;
	};
	this . move_right = function (dimensions) {this . location . x += 1; this . clamp_right (dimensions, this . rotate_block ());};
	this . clamp_left = function (dimensions, block) {
		if (this . location . x < 1) {for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [y] [0]) {this . location . x = 1; return;}}}}
		if (this . location . x < 0) {for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [y] [1]) {this . location . x = 0; return;}}}}
		if (this . location . x < -1) this . location = -1;
	};
	this . move_left = function (dimensions) {this . location . x -= 1; this . clamp_left (dimensions, this . rotate_block ());};
	this . clamp_top = function (dimensions, block) {
		if (this . location . y + 2 > dimensions . height) {
			for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [0] [y]) {this . location . y = dimensions . height - 2; return;}}}
		}
		if (this . location . y + 1 > dimensions . height) {
			for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [1] [y]) {this . location . y = dimensions . height - 1; return;}}}
		}
		if (this . location . y > dimensions . height) this . location . y = dimensions . height;
	};
	this . move_up = function (dimensions) {this . location . y += 1; this . clamp_top (dimensions, this . rotate_block ());};
	this . clamp_bottom = function (dimensions, block) {
		if (this . location . y < 1) {for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [2] [y]) {this . location . y = 1; return;}}}}
		if (this . location . y < 0) {for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [1] [y]) {this . location . y = 0; return;}}}}
		if (this . location . y < -1) this . location = -1;
	};
	this . move_down = function (dimensions) {this . location . y -= 1; this . clamp_bottom (dimensions, this . rotate_block ());};
	this . clamp = function (dimensions, block) {
		this . clamp_bottom (dimensions, block);
		this . clamp_top (dimensions, block);
		this . clamp_left (dimensions, block);
		this . clamp_right (dimensions, block);
	};
	this . rotate = function (matrix, dimensions) {this . rotation = mtm (this . rotation, matrix); this . clamp (dimensions, this . rotate_block ());};
	this . addToWell = function (well) {
		well . addBlock (this . location . x, this . location . y);	
	};
	this . draw = function (ctx, dims) {
//		ctx . matrix = translate (m, this . location . x * dims, 0, 0);
		//var x = dims . side * (this . location . x - dims . width * 0.5);
		var x = 0, y = 0, z = 0;
		//var y = dims . side * (this . location . y - dims . height * 0.5);
		//var z = dims . side * this . location . z;
		var s = dims . side;
		var zs = z + s, zms= z - s, yms = y - s, ymss = y - s - s, xss = x + s + s; xsss = x + 3 * s;
		var xs = x + s;
		var m = ctx . matrix;
		var mm = m;
		mm = translate (mm, - s * (dims . width * 0.5 - this . location . x - 0.5),
							s * (dims . height * 0.5 - this . location . y - 0.5), s * (this . location . z + 0.5));
		//mm = rollz (mm, angle); angle += 0.01;
		mm = mtm (this . rotation, mm);
		mm = translate (mm, -1.5 * s, 0.5 * s, -0.5 * s);
		ctx . matrix = mm;
		ctx . strokeStyle = '#ff2222'; ctx . lineWidth = 2;
		ctx . beginPath ();
		ctx . moveto (x, y, z); ctx . lineto (xs, y, z); ctx . lineto (xs, y, zms); ctx . lineto (xss, y, zms);
			ctx . lineto (xss, y, z); ctx . lineto (xsss, y, z); ctx . lineto (xsss, y, zs); ctx . lineto (x, y, zs); ctx . lineto (x, y, z);
			ctx . lineto (x, ymss, z); ctx . lineto (xs, ymss, z), ctx . lineto (xs, y, z);
		ctx . moveto (x, y, zs); ctx . lineto (x, ymss, zs); ctx . lineto (xs, ymss, zs), ctx . lineto (xs, yms, zs);
			ctx . lineto (xsss, yms, zs); ctx . lineto (xsss, y, zs);
		ctx . moveto (xsss, y, z); ctx . lineto (xsss, yms, z); ctx . lineto (xss, yms, z); ctx . lineto (xss, y, z);
		ctx . moveto (xss, yms, z); ctx . lineto (xss, yms, zms); ctx . lineto (xss, y, zms);
		ctx . moveto (xss, yms, zms); ctx . lineto (xs, yms, zms); ctx . lineto (xs, y, zms);
		ctx . moveto (xs, yms, zms); ctx . lineto (xs, yms, zs);
		ctx . moveto (x, ymss, z); ctx . lineto (x, ymss, zs);
		ctx . moveto (xs, ymss, z); ctx . lineto (xs, ymss, zs);
		ctx . moveto (xsss, yms, z); ctx . lineto (xsss, yms, zs);
		ctx . stroke ();
		ctx . matrix = m;
	};
};

var block = new Block ();

var Well = function () {
	this . dimensions = {width: 7, height: 7, depth: 12, side: 40};
	this . colours = ['blue', 'red', 'magenta', 'green', 'cyan', 'yellow', 'white', 'orange', 'blue', 'red', 'magenta', 'red', 'yellow', 'cyan'];
	this . content = [];
	this . initialiseContent = function () {
		this . content = [];
		for (var z = 0; z < this . dimensions . depth; z++) {
			var layer = []; this . content . push (layer);
			for (var x = 0; x < this . dimensions . width; x++) {
				var column = []; layer . push (column);
				for (var y = 0; y < this . dimensions . height; y++) {
					column . push (false);
				}
			}
		}
	};
	this . addBlock = function (x, y) {
		if (this . content [0] [x] [y]) return false;
		for (var depth = 0; depth < this . dimensions . depth - 1; depth++) {
			if (this . content [depth + 1] [x] [y] && ! this . content [depth] [x] [y]) return this . content [depth] [x] [y] = true;
		}
		return this . content [this . dimensions . depth - 1] [x] [y] = true;
	};
	this . initialiseContent ();
	this . insertRandomBlock = function () {
		this . content [Math . floor (this . dimensions . depth * Math . random ())]
						[Math . floor (this . dimensions . width * Math . random ())]
						[Math . floor (this . dimensions . height * Math . random ())] = true;
	};
	//for (var ind = 0; ind < 4; ind++) this . insertRandomBlock ();
	this . reSide = function (width, height) {
		this . dimensions . side = Math . min (width / this . dimensions . width * 0.96, height / this . dimensions . height * 0.96);
	};
	this . drawWell = function (ctx) {
		ctx . beginPath ();
		var right = this . dimensions . width * 0.5 * this . dimensions . side, left = - right;
		var bottom = this . dimensions . height * 0.5 * this . dimensions . side, top = - bottom;
		var depth = this . dimensions . depth * this . dimensions . side;
		for (var y = 1; y < this . dimensions . height; y++) {
			var yy = top + this . dimensions . side * y;
			ctx . moveto (left, yy, 0); ctx . lineto (left, yy, depth); ctx . lineto (right, yy, depth); ctx . lineto (right, yy, 0);
		}
		for (var x = 1; x < this . dimensions . width; x++) {
			var xx = left + this . dimensions . side * x;
			ctx . moveto (xx, top, 0); ctx . lineto (xx, top, depth); ctx . lineto (xx, bottom, depth); ctx . lineto (xx, bottom, 0);
		}
		for (var z = 0; z <= this . dimensions . depth; z++) {
			var zz = this . dimensions . side * z;
			ctx . moveto (left, top, zz); ctx . lineto (right, top, zz); ctx . lineto (right, bottom, zz); ctx . lineto (left, bottom, zz); ctx . lineto (left, top, zz);
		}
		ctx . moveto (left, top, 0); ctx . lineto (left, top, depth);
		ctx . moveto (right, top, 0); ctx . lineto (right, top, depth);
		ctx . moveto (right, bottom, 0); ctx . lineto (right, bottom, depth);
		ctx . moveto (left, bottom, 0); ctx . lineto (left, bottom, depth);
		ctx . stroke ();
	};
	this . drawContent = function (ctx) {
		var side = this . dimensions . side;
		var left = -0.5 * this . dimensions . width * side;
		var top = 0.5 * this . dimensions . height * side;
		for (var layer = this . dimensions . depth - 1; layer >= 0; layer--) {
			ctx . fillStyle = this . colours [layer];
			var depth = layer * side;
			for (var x = 0; x < this . dimensions . width; x++) {
				for (var y = 0; y < this . dimensions . height; y++) {
					if (this . content [layer] [x] [y]) {
						var a = left + side * x, b = a + side, c = top - side * y - side, d = c + side, dd = depth + side;
						ctx . beginPath ();
						ctx . moveto (a, c, depth), ctx . lineto (b, c, depth); ctx . lineto (b, d, depth); ctx . lineto (a, d, depth), ctx . closePath ();
						ctx . fill ();
						ctx . stroke ();
						if (y + 1 < this . dimensions . height * 0.5) {
							ctx . beginPath ();
							ctx . moveto (a, c, depth), ctx . lineto (a, c, dd); ctx . lineto (b, c, dd); ctx . lineto (b, c, depth);
							ctx . fill ();
						}
						if (y > this . dimensions . height * 0.5) {
							ctx . beginPath ();
							ctx . moveto (b, d, depth), ctx . lineto (b, d, dd); ctx . lineto (a, d, dd); ctx . lineto (a, d, depth);
							ctx . fill ();
						}
						if (x > this . dimensions . width * 0.5) {
							ctx . beginPath ();
							ctx . moveto (a, c, depth), ctx . lineto (a, c, dd); ctx . lineto (a, d, dd); ctx . lineto (a, d, depth);
							ctx . fill ();
						}
						if (x + 1 < this . dimensions . width * 0.5) {
							ctx . beginPath ();
							ctx . moveto (b, c, depth), ctx . lineto (b, c, dd); ctx . lineto (b, d, dd); ctx . lineto (b, d, depth);
							ctx . fill ();
						}
					}
				}
			}
		}
	};
	this . draw = function (ctx, width, height) {
		ctx . clearRect (0, 0, width, height);
		ctx . strokeStyle = '#44ff44';
		ctx . resetTransform ();
		ctx . lineWidth = 1;
		ctx . translate (width * 0.5, height * 0.5);
		this . drawWell (ctx);
		this . drawContent (ctx);
	}
};

var well = new Well ();

var resize = function () {
	canvas . width = window . innerWidth;
	canvas . height = window . innerHeight;
	well . reSide (window . innerWidth, window . innerHeight);
	well . draw (ctx, window . innerWidth, window . innerHeight);
	block . draw (ctx, well . dimensions);
};

//setInterval (resize, 50);
resize ();

var ctrl = function (event) {
	switch (event . key) {
	case "ArrowRight": block . move_right (well . dimensions); break;
	case "ArrowLeft": block . move_left (well . dimensions); break;
	case "ArrowUp": block . move_up (well . dimensions); break;
	case "ArrowDown": block . move_down (well . dimensions); break;
	case "d": block . rotate ([[0, -1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "e": block . rotate ([[0, 1, 0, 0], [-1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "a": block . rotate ([[1, 0, 0, 0], [0, 0, -1, 0], [0, 1, 0, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "q": block . rotate ([[1, 0, 0, 0], [0, 0, 1, 0], [0, -1, 0, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "w": block . rotate ([[0, 0, -1, 0], [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "s": block . rotate ([[0, 0, 1, 0], [0, 1, 0, 0], [-1, 0, 0, 0], [0, 0, 0, 1]], well . dimensions); break;
	case " ": block . addToWell (well); break;
	default: break;
	}
	resize ();
};

</script>


</html>

