<!--
///////////////////////////////////////////////////////////////////////////////////
//                     Copyright (C) 2018 Dr Robert P. Wolf                      //
//                                                                               //
// Permission is hereby granted, free of charge, to any person obtaining a copy  //
// of this software and associated documentation files (the "Software"), to deal //
// in the Software without restriction, including without limitation the rights  //
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell     //
// copies of the Software, and to permit persons to whom the Software is         //
// furnished to do so, subject to the following conditions:                      //
//                                                                               //
// The above copyright notice and this permission notice shall be included in    //
// all copies or substantial portions of the Software.                           //
//                                                                               //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   //
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER        //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, //
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN     //
// THE SOFTWARE.                                                                 //
///////////////////////////////////////////////////////////////////////////////////

-->

<html>

<head>
	<title>TETRIS 3D</title>
	<style>
	td {padding: 6px;}
	</style>
</head>

<body bgcolor=black style = "margin: 0;" onkeydown="javascript: ctrl (event . key . toLowerCase ());" >
	<div>
		<canvas id=tetris />
	</div>
	<div style="position: absolute; top: 0px; right: 0px; text-align: center; color: #88ff88; font-family: arial;">
		<input type=button value="ROLL X UP (A)" style="width: 160px;" onclick="javascript: ctrl ('a');" />
		<input type=button value="ROLL X DOWN (Q)" style="width: 160px;" onclick="javascript: ctrl ('q');" />
		<br />
		<input type=button value="ROLL Y LEFT (S)" style="width: 160px;" onclick="javascript: ctrl ('s');" />
		<input type=button value="ROLL Y RIGHT (W)" style="width: 160px;" onclick="javascript: ctrl ('w');" />
		<br />
		<input type=button value="ROLL Z RIGHT (D)" style="width: 160px;" onclick="javascript: ctrl ('d');" />
		<input type=button value="ROLL Z LEFT (E)" style="width: 160px;" onclick="javascript: ctrl ('e');" />
		<br />
		<input type=button value="MOVE LEFT (&#x21e6)" style="width: 160px;" onclick="javascript: ctrl ('arrowleft');" />
		<input type=button value="MOVE RIGHT (&#x21e8)" style="width: 160px;" onclick="javascript: ctrl ('arrowright');" />
		<br />
		<input type=button value="MOVE UP (&#x21e7)" style="width: 160px;" onclick="javascript: ctrl ('arrowup');" />
		<input type=button value="MOVE DOWN (&#x21e9)" style="width: 160px;" onclick="javascript: ctrl ('arrowdown');" />
		<div id=score />SCORE</div>
		<br />
		BEST (lowest) SCORES
		<br />
		<table style="color: #88ff88; font-family: arial; text-align: right;" align=center >
			<tr><td>1</td><td id=name_0 ></td><td id=score_0 ></td></tr>
			<tr><td>2</td><td id=name_1 ></td><td id=score_1 ></td></tr>
			<tr><td>3</td><td id=name_2 ></td><td id=score_2 ></td></tr>
			<tr><td>4</td><td id=name_3 ></td><td id=score_3 ></td></tr>
			<tr><td>5</td><td id=name_4 ></td><td id=score_4 ></td></tr>
			<tr><td>6</td><td id=name_5 ></td><td id=score_5 ></td></tr>
			<tr><td>7</td><td id=name_6 ></td><td id=score_6 ></td></tr>
			<tr><td>8</td><td id=name_7 ></td><td id=score_7 ></td></tr>
			<tr><td>9</td><td id=name_8 ></td><td id=score_8 ></td></tr>
			<tr><td>10</td><td id=name_9 ></td><td id=score_9 ></td></tr>
		</table>
		<input type=button value="RELEASE (spacebar)" style="width: 320px;" onclick="javascript: ctrl (' ');" />
	</div>
</body>

<script>

var setup = {};
try {setup = JSON . parse (unescape (window . location . search) . substring (1));} catch (error) {setup = {};}


var vtm = function (vector, matrix) {
	var v = [];
	for (var y = 0; y < matrix . length; y++) {
		var vv = 0;
		for (var x = 0; x < vector . length; x++) {
			vv += vector [x] * matrix [y] [x];
		}
		v . push (vv);
	}
	return v;
};

var mtm = function (m1, m2) {
	var m = [];
	for (var y = 0; y < m2 . length; y++) {
		var mm = []; m . push (mm);
		for (var x = 0; x < m1 . length; x++) {
			var value = 0.0;
			for (var i = 0; i < m2 . length; i++) {
				value += m1 [i] [x] * m2 [y] [i];
			}
			mm . push (value);
		}
	}
	return m;
};

var rollz = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[cosine, - sine, 0, 0], [sine, cosine, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], m);
};

var rollx = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[1, 0, 0, 0], [0, cosine, - sine, 0], [0, sine, cosine, 0], [0, 0, 0, 1]], m);
};

var rolly = function (m, angle) {
	var sine = Math . sin (angle), cosine = Math . cos (angle);
	return mtm ([[cosine, 0, - sine, 0], [0, 1, 0, 0], [sine, 0, cosine, 0], [0, 0, 0, 1]], m);
};

var translate = function (m, x, y, z) {return mtm ([[1, 0, 0, x], [0, 1, 0, y], [0, 0, 1, z], [0, 0, 0, 1]], m);};

var context3d = function (canvas) {
	var ctx = canvas . getContext ('2d');
	ctx . screen = 600.0;
	ctx . rollz = function (angle) {
		var sine = Math . sin (angle), cosine = Math . cos (angle);
		var m = [[cosine, - sine, 0, 0], [sine, cosine, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
		ctx . matrix = mtm (m, ctx . matrix);
	};
	ctx . scale = function (scale) {
		var m = [[scale, 0, 0, 0], [0, scale, 0, 0], [0, 0, scale, 0], [0, 0, 0, 1]];
		ctx . matrix = mtm (ctx . matrix, m);
	};
	ctx . moveto = function (x, y, z) {
		var v = vtm ([x, y, z, 1], ctx . matrix);
		var scz = ctx . screen / (ctx . screen + v [2]);
		ctx . moveTo (v [0] * scz, v [1] * scz);
	};
	ctx . lineto = function (x, y, z) {
		var v = vtm ([x, y, z, 1], ctx . matrix);
		var scz = ctx . screen / (ctx . screen + v [2]);
		ctx . lineTo (v [0] * scz, v [1] * scz);
	};
	ctx . unity = function () {return [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];}
	ctx . reset_transform = function () {ctx . matrix = ctx . unity ();}
	ctx . reset_transform ();
	ctx . matrices = [];
	ctx . push_matrix = function () {ctx . matrices . push (ctx . matrix);};
	ctx . pop_matrix = function () {if (ctx . matrices . length > 0) ctx . matrix = ctx . matrices . pop ();};
	return ctx;
};

var canvas = document . getElementById ('tetris');
var ctx = context3d (canvas);

var angle = 0;

var Block = function () {
	this . location = {x: 8, y: 1, z: 0};
	this . rotation = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
	this . rotate_block = function () {
		var block = [[[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0]]];
		for (var layer = 0; layer < 3; layer++) {
			for (var row = 0; row < 3; row++) {
				for (var el = 0; el < 3; el++) {
					var v = vtm ([el - 1, row - 1, layer - 1, 1], this . rotation);
					block [v [2] + 1] [v [1] + 1] [v [0] + 1] = this . block [layer] [row] [el];
				}
			}
		}
		return block;
	};
	this . clamp_right = function (dimensions, block) {
		if (this . location . x + 2 > dimensions . width) {
			for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [y] [2]) {this . location . x = dimensions . width - 2; return;}}}
		}
		if (this . location . x + 1 > dimensions . width) {
			for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [y] [1]) {this . location . x = dimensions . width - 1; return;}}}
		}
		if (this . location . x > dimensions . width) this . location . x = dimensions . width;
	};
	this . move_right = function (dimensions) {this . location . x += 1; this . clamp_right (dimensions, this . rotate_block ());};
	this . clamp_left = function (dimensions, block) {
		if (this . location . x < 1) {for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [y] [0]) {this . location . x = 1; return;}}}}
		if (this . location . x < 0) {for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [y] [1]) {this . location . x = 0; return;}}}}
		if (this . location . x < -1) this . location = -1;
	};
	this . move_left = function (dimensions) {this . location . x -= 1; this . clamp_left (dimensions, this . rotate_block ());};
	this . clamp_top = function (dimensions, block) {
		if (this . location . y + 2 > dimensions . height) {
			for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [0] [y]) {this . location . y = dimensions . height - 2; return;}}}
		}
		if (this . location . y + 1 > dimensions . height) {
			for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [1] [y]) {this . location . y = dimensions . height - 1; return;}}}
		}
		if (this . location . y > dimensions . height) this . location . y = dimensions . height;
	};
	this . move_up = function (dimensions) {this . location . y += 1; this . clamp_top (dimensions, this . rotate_block ());};
	this . clamp_bottom = function (dimensions, block) {
		if (this . location . y < 1) {for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [2] [y]) {this . location . y = 1; return;}}}}
		if (this . location . y < 0) {for (var x = 0; x < 3; x++) {for (var y = 0; y < 3; y++) {if (block [x] [1] [y]) {this . location . y = 0; return;}}}}
		if (this . location . y < -1) this . location = -1;
	};
	this . move_down = function (dimensions) {this . location . y -= 1; this . clamp_bottom (dimensions, this . rotate_block ());};
	this . clamp = function (dimensions, block) {
		this . clamp_bottom (dimensions, block);
		this . clamp_top (dimensions, block);
		this . clamp_left (dimensions, block);
		this . clamp_right (dimensions, block);
	};
	this . readjust_position = function (well) {
		this . location . x = Math . floor (well . dimensions . width * 0.5);
		this . location . y = Math . floor (well . dimensions . height * 0.5);
		this . location . x = Math . floor (Math . random () * well . dimensions . width);
		this . location . y = Math . floor (Math . random () * well . dimensions . height);
		this . clamp (well . dimensions, this . rotate_block ());
	};
	this . rotate = function (matrix, dimensions) {this . rotation = mtm (this . rotation, matrix); this . clamp (dimensions, this . rotate_block ());};
	this . level = function (well) {
		var block = this . rotate_block ();
		var lll = 16384;
		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 3; x++) {
				var l = well . level (this . location . x + x - 1, this . location . y + y - 1);
				var ll;
				if (block [2] [2 - y] [x]) ll = l - 2;
				else if (block [1] [2 - y] [x]) ll = l - 1;
				else if (block [0] [2 - y] [x]) ll = l;
				else ll = 16384;
//				console . log ([x, y, ll]);
				lll = Math . min (lll, ll);
			}
		}
//		console . log ("================");
		return lll;
	};
	this . addToWell = function (well) {
		//var depth = well . dimensions . depth - 3;
		var depth = this . level (well);
//		console . log (depth);
		var block = this . rotate_block ();
		for (var d = 0; d < 3; d++) {
			for (var x = 0; x < 3; x++) {
				for (var y = 0; y < 3; y++) {
//					console . log ("Depth = ", depth, " + ", d);
					if (block [d] [y] [x] && depth + d < 0) {alert ("Game lost!\nTry again...."); return true;}
					if (block [d] [y] [x]) well . content [depth + d] [this . location . x + x - 1] [this . location . y - y + 1] = true;
				}
			}
		}
		well . addScore (this . score);
		return false;
	};
	this . drawer = function (ctx, dims) {
		var side = dims . side;
		ctx . push_matrix ();
		ctx . matrix = translate (ctx . matrix,
			- dims . side * (dims . width * 0.5 - this . location . x - 0.5),
			dims . side * (dims . height * 0.5 - this . location . y - 0.5),
			dims . side * (this . location . z + 0.5));
		ctx . matrix = mtm (this . rotation, ctx . matrix);
		ctx . matrix = translate (ctx . matrix, -1.5 * dims . side, 0.5 * dims . side, -0.5 * dims . side);
		this . draw (ctx, dims);
		ctx . pop_matrix ();
	};
};

var Block1 = function () {
	Block . call (this);
	this . score = 1;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [false, true, false], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s;
		ctx . beginPath ();
		ctx . moveto (s, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, 0, 0); ctx . lineto (s, 0, 0); ctx . lineto (s, ms, 0);
		ctx . lineto (s, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, 0, s); ctx . lineto (s, 0, s); ctx . lineto (s, ms, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . stroke ();
	};
};

var Block2 = function () {
	Block . call (this);
	this . score = 2;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, false], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . stroke ();
	};
};

var Block31 = function () {
	Block . call (this);
	this . score = 3;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side;
		var x = 0, y = 0, z = 0;
		var xsss = x + 3 * s, yms = y - s, zs = z + s;
		ctx . beginPath ();
		ctx . moveto (x, y, z); ctx . lineto (xsss, y, z), ctx . lineto (xsss, yms, z); ctx . lineto (x, yms, z); ctx . lineto (x, y, z);
		ctx . lineto (x, y, zs); ctx . lineto (xsss, y, zs), ctx . lineto (xsss, yms, zs); ctx . lineto (x, yms, zs); ctx . lineto (x, y, zs);
		ctx . moveto (x, yms, z); ctx . lineto (x, yms, zs);
		ctx . moveto (xsss, yms, z); ctx . lineto (xsss, yms, zs);
		ctx . moveto (xsss, y, z); ctx . lineto (xsss, y, zs);
		ctx . stroke ();
	};
};

var Block32 = function () {
	Block . call (this);
	this . score = 3;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, false], [false, true, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, s, 0); ctx . lineto (s, s, 0); ctx . lineto (s, 0, 0);
			ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, s, s); ctx . lineto (s, s, s); ctx . lineto (s, 0, s);
			ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . stroke ();
	};
};

var Block41 = function () {
	Block . call (this);
	this . score = 4;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, true], [false, false, true]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (sss, ms, 0); ctx . lineto (sss, s, 0); ctx . lineto (ss, s, 0); ctx . lineto (ss, 0, 0);
			ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (sss, ms, s); ctx . lineto (sss, s, s); ctx . lineto (ss, s, s); ctx . lineto (ss, 0, s);
			ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, s, 0); ctx . lineto (sss, s, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . stroke ();
	};
};

var Block42 = function () {
	Block . call (this);
	this . score = 4;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, true], [false, true, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (sss, ms, 0); ctx . lineto (sss, 0, 0); ctx . lineto (ss, 0, 0); ctx . lineto (ss, s, 0);
			ctx . lineto (s, s, 0); ctx . lineto (s, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (sss, ms, s); ctx . lineto (sss, 0, s); ctx . lineto (ss, 0, s); ctx . lineto (ss, s, s);
			ctx . lineto (s, s, s); ctx . lineto (s, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . stroke ();
	};
};

var Block43 = function () {
	Block . call (this);
	this . score = 4;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, false], [false, true, true]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, 0, 0); ctx . lineto (sss, 0, 0); ctx . lineto (sss, s, 0);
			ctx . lineto (s, s, 0); ctx . lineto (s, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, 0, s); ctx . lineto (sss, 0, s); ctx . lineto (sss, s, s);
			ctx . lineto (s, s, s); ctx . lineto (s, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (sss, s, 0); ctx . lineto (sss, s, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . stroke ();
	};
};

var Block44 = function () {
	Block . call (this);
	this . score = 4;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, false], [false, true, false]],
					[[false, false, false], [false, true, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, s, 0); ctx . lineto (s, s, 0); ctx . lineto (s, 0, 0);
			ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (s, ms, s); ctx . lineto (s, ms, ss); ctx . lineto (ss, ms, ss); ctx . lineto (ss, 0, ss);
			ctx . lineto (ss, 0, s); ctx . lineto (ss, s, s); ctx . lineto (s, s, s); ctx . lineto (s, 0, s);
			ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, ss);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, ss); ctx . lineto (ss, 0, ss);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (s, ms, s); ctx . lineto (s, 0, s); ctx . lineto (ss, 0, s);
		ctx . moveto (s, ms, ss); ctx . lineto (s, 0, ss);
		ctx . stroke ();
	};
};

var Block45 = function () {
	Block . call (this);
	this . score = 4;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, false], [false, true, false]],
					[[false, false, false], [false, false, false], [false, true, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, s, 0); ctx . lineto (s, s, 0); ctx . lineto (s, 0, 0);
			ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, 0, s); ctx . lineto (ss, 0, ss); ctx . lineto (ss, s, ss);
			ctx . lineto (s, s, ss); ctx . lineto (s, 0, ss); ctx . lineto (s, 0, 0);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (0, ms, s); ctx . lineto (0, 0, s); ctx . lineto (ss, 0, s);
		ctx . moveto (s, 0, ss); ctx . lineto (ss, 0, ss);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, ss);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, ss);
		ctx . stroke ();
	};
};

var Block46 = function () {
	Block . call (this);
	this . score = 4;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [true, true, false], [true, true, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, s, 0); ctx . lineto (0, s, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, s, s); ctx . lineto (0, s, s); ctx . lineto (0, ms, s);
		ctx . moveto (0, s, 0); ctx . lineto (0, s, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . stroke ();
	};
};

var Block47 = function () {
	Block . call (this);
	this . score = 4;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, false], [false, true, true], [false, true, false]],
					[[false, false, false], [false, false, false], [false, true, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (s, s, 0); ctx . lineto (s, ms, 0); ctx . lineto (sss, ms, 0); ctx . lineto (sss, 0, 0);
			ctx . lineto (ss, 0, 0); ctx . lineto (ss, s, 0); ctx . lineto (s, s, 0);
		ctx . lineto (s, s, ss); ctx . lineto (s, 0, ss); ctx . lineto (s, 0, s); ctx . lineto (s, ms, s); ctx . lineto (sss, ms, s);
			ctx . lineto (sss, 0, s); ctx . lineto (s, 0, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, ss); ctx . lineto (ss, 0, ss); ctx . lineto (ss, 0, 0);
		ctx . moveto (s, ms, 0); ctx . lineto (s, ms, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (s, 0, ss); ctx . lineto (ss, 0, ss);
		ctx . moveto (s, s, ss); ctx . lineto (ss, s, ss);
		ctx . stroke ();
	};
};

var Block51 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, true, false], [false, false, false]],
					[[true, false, false], [true, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var x = 0, y = 0, z = 0;
		var s = dims . side;
		var zs = z + s, zms= z - s, yms = y - s, ymss = y - s - s, xss = x + s + s; xsss = x + 3 * s;
		var xs = x + s;
		ctx . beginPath ();
		ctx . moveto (x, y, z); ctx . lineto (xs, y, z); ctx . lineto (xs, y, zms); ctx . lineto (xss, y, zms);
			ctx . lineto (xss, y, z); ctx . lineto (xsss, y, z); ctx . lineto (xsss, y, zs); ctx . lineto (x, y, zs); ctx . lineto (x, y, z);
			ctx . lineto (x, ymss, z); ctx . lineto (xs, ymss, z), ctx . lineto (xs, y, z);
		ctx . moveto (x, y, zs); ctx . lineto (x, ymss, zs); ctx . lineto (xs, ymss, zs), ctx . lineto (xs, yms, zs);
			ctx . lineto (xsss, yms, zs); ctx . lineto (xsss, y, zs);
		ctx . moveto (xsss, y, z); ctx . lineto (xsss, yms, z); ctx . lineto (xss, yms, z); ctx . lineto (xss, y, z);
		ctx . moveto (xss, yms, z); ctx . lineto (xss, yms, zms); ctx . lineto (xss, y, zms);
		ctx . moveto (xss, yms, zms); ctx . lineto (xs, yms, zms); ctx . lineto (xs, y, zms);
		ctx . moveto (xs, yms, zms); ctx . lineto (xs, yms, zs);
		ctx . moveto (x, ymss, z); ctx . lineto (x, ymss, zs);
		ctx . moveto (xs, ymss, z); ctx . lineto (xs, ymss, zs);
		ctx . moveto (xsss, yms, z); ctx . lineto (xsss, yms, zs);
		ctx . stroke ();
	};
};

var Block52 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, true, false], [false, false, false]],
					[[false, false, false], [true, true, true], [true, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, sss = ss + s, ms = - s;
		ctx . beginPath ();
		ctx . moveto (0, ms, s); ctx . lineto (sss, ms, s); ctx . lineto (sss, 0, s); ctx . lineto (s, 0, s); ctx . lineto (s, s, s); ctx . lineto (0, s, s);
		ctx . lineto (0, ms, s); ctx . lineto (0, ms, 0); ctx . lineto (s, ms, 0); ctx . lineto (s, ms, ms); ctx . lineto (ss, ms, ms); ctx . lineto (ss, ms, 0);
		ctx . lineto (sss, ms, 0); ctx . lineto (sss, 0, 0); ctx . lineto (ss, 0, 0); ctx . lineto (ss, 0, ms); ctx . lineto (s, 0, ms); ctx . lineto (s, 0, s);
		ctx . moveto (0, ms, 0); ctx . lineto (0, s, 0); ctx . lineto (s, s, 0); ctx . lineto (s, ms, 0);
		ctx . moveto (0, s, 0); ctx . lineto (0, s, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, 0, 0);
		ctx . moveto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . moveto (s, ms, ms); ctx . lineto (s, 0, ms);
		ctx . stroke ();
	};
};

var Block53 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, true, false], [false, false, false]],
					[[false, false, false], [true, true, true], [false, true, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ss = s + s, ms = - s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (s, ms, 0); ctx . lineto (s, ms, ms); ctx . lineto (ss, ms, ms); ctx . lineto (ss, ms, 0);
			ctx . lineto (sss, ms, 0); ctx . lineto (sss, 0, 0); ctx . lineto (ss, 0, 0); ctx . lineto (ss, s, 0);
			ctx . lineto (s, s, 0); ctx . lineto (s, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s);
			ctx . lineto (sss, ms, s); ctx . lineto (sss, 0, s); ctx . lineto (ss, 0, s); ctx . lineto (ss, s, s);
			ctx . lineto (s, s, s); ctx . lineto (s, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (ss, 0, ms); ctx . lineto (ss, 0, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . moveto (s, 0, ms); ctx . lineto (s, 0, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (s, ms, 0); ctx . lineto (s, 0, 0); ctx . lineto (ss, 0, 0); ctx . lineto (ss, ms, 0);
		ctx . moveto (s, ms, ms); ctx . lineto (s, 0, ms); ctx . lineto (ss, 0, ms); ctx . lineto (ss, ms, ms);
		ctx . stroke ();
	};
};

var Block5Z = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, true], [true, true, true], [true, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = - s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, mss, 0); ctx . lineto (sss, mss, 0); ctx . lineto (sss, 0, 0);
			ctx . lineto (s, 0, 0); ctx . lineto (s, s, 0); ctx . lineto (0, s, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, mss, s); ctx . lineto (sss, mss, s); ctx . lineto (sss, 0, s);
			ctx . lineto (s, 0, s); ctx . lineto (s, s, s); ctx . lineto (0, s, s); ctx . lineto (0, ms, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (sss, mss, 0); ctx . lineto (sss, mss, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (0, s, 0); ctx . lineto (0, s, s);
		ctx . stroke ();
	};
};

var Block5P = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, true, false], [true, true, true], [false, true, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = - s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (s, ms, 0); ctx . lineto (s, mss, 0); ctx . lineto (ss, mss, 0); ctx . lineto (ss, ms, 0);
		ctx . lineto (sss, ms, 0); ctx . lineto (sss, 0, 0); ctx . lineto (ss, 0, 0); ctx . lineto (ss, s, 0); ctx . lineto (s, s, 0);
		ctx . lineto (s, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (s, ms, s); ctx . lineto (s, mss, s); ctx . lineto (ss, mss, s); ctx . lineto (ss, ms, s);
		ctx . lineto (sss, ms, s); ctx . lineto (sss, 0, s); ctx . lineto (ss, 0, s); ctx . lineto (ss, s, s); ctx . lineto (s, s, s);
		ctx . lineto (s, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (s, ms, 0); ctx . lineto (s, ms, s);
		ctx . moveto (s, mss, 0); ctx . lineto (s, mss, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . stroke ();
	};
};

var Block5E = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[true, false, true], [true, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = - s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, mss, 0); ctx . lineto (s, mss, 0); ctx . lineto (s, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, mss, 0);
		ctx . lineto (sss, mss, 0); ctx . lineto (sss, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, mss, 0);
		ctx . lineto (0, mss, s); ctx . lineto (s, mss, s); ctx . lineto (s, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, mss, s);
		ctx . lineto (sss, mss, s); ctx . lineto (sss, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, mss, s);
		ctx . moveto (s, mss, 0); ctx . lineto (s, mss, s);
		ctx . moveto (s, ms, 0); ctx . lineto (s, ms, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (sss, mss, 0); ctx . lineto (sss, mss, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . stroke ();
	};
};

var Block5LL = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, true, false], [true, true, true], [true, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = - s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (s, ms, 0); ctx . lineto (s, mss, 0); ctx . lineto (ss, mss, 0); ctx . lineto (ss, ms, 0); ctx . lineto (sss, ms, 0);
		ctx . lineto (sss, 0, 0); ctx . lineto (s, 0, 0); ctx . lineto (s, s, 0); ctx . lineto (0, s, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (s, ms, s); ctx . lineto (s, mss, s); ctx . lineto (ss, mss, s); ctx . lineto (ss, ms, s); ctx . lineto (sss, ms, s);
		ctx . lineto (sss, 0, s); ctx . lineto (s, 0, s); ctx . lineto (s, s, s); ctx . lineto (0, s, s); ctx . lineto (0, ms, s);
		ctx . moveto (s, ms, 0); ctx . lineto (s, ms, s);
		ctx . moveto (s, mss, 0); ctx . lineto (s, mss, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (0, s, 0); ctx . lineto (0, s, s);
		ctx . stroke ();
	};
};

var Block54 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [true, false, false], [false, false, false]],
					[[false, false, false], [true, true, true], [true, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = - s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, ms); ctx . lineto (s, ms, ms); ctx . lineto (s, ms, 0); ctx . lineto (sss, ms, 0); ctx . lineto (sss, 0, 0); ctx . lineto (s, 0, 0);
		ctx . lineto (s, s, 0); ctx . lineto (0, s, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, 0, ms); ctx . lineto (0, ms, ms);
		ctx . lineto (0, ms, s); ctx . lineto (sss, ms, s); ctx . lineto (sss, 0, s); ctx . lineto (s, 0, s); ctx . lineto (s, s, s);
		ctx . lineto (0, s, s); ctx . lineto (0, ms, s);
		ctx . moveto (s, ms, ms); ctx . lineto (s, 0, ms); ctx . lineto (0, 0, ms);
		ctx . moveto (s, ms, 0); ctx . lineto (s, 0, 0); ctx . lineto (0, 0, 0);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (s, 0, ms); ctx . lineto (s, 0, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (0, s, 0); ctx . lineto (0, s, s);
		ctx . stroke ();
	};
};

var Block5S1 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, true, false], [false, false, false]],
					[[true, true, false], [false, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, mss, 0), ctx . lineto (ss, mss, 0); ctx . lineto (ss, ms, 0); ctx . lineto (sss, ms, 0); ctx . lineto (sss, 0, 0);
		ctx . lineto (ss, 0, 0), ctx . lineto (ss, 0, ms); ctx . lineto (s, 0, ms); ctx . lineto (s, ms, ms); ctx . lineto (s, ms, 0);
		ctx . lineto (0, ms, 0); ctx . lineto (0, mss, 0);
		ctx . lineto (0, mss, s); ctx . lineto (ss, mss, s); ctx . lineto (ss, ms, s); ctx . lineto (sss, ms, s); ctx . lineto (sss, 0, s);
		ctx . lineto (s, 0, s); ctx . lineto (s, ms, s); ctx . lineto (0, ms, s); ctx . lineto (0, mss, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (ss, ms, ms); ctx . lineto (ss, ms, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (s, 0, ms); ctx . lineto (s, 0, s);
		ctx . moveto (0, ms, 0); ctx . lineto (0, ms, s);
		ctx . moveto (s, ms, ms); ctx . lineto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . moveto (s, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, 0, 0);
		ctx . stroke ();
	};
};

var Block5S2 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, true, false], [false, false, false]],
					[[false, false, false], [true, true, false], [false, true, true]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (s, ms, 0); ctx . lineto (s, ms, ms); ctx . lineto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . lineto (ss, 0, 0); ctx . lineto (sss, 0, 0); ctx . lineto (sss, s, 0); ctx . lineto (s, s, 0);
		ctx . lineto (s, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, 0, s); ctx . lineto (sss, 0, s);
		ctx . lineto (sss, s, s); ctx . lineto (s, s, s); ctx . lineto (s, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (ss, 0, ms); ctx . lineto (s, 0, ms); ctx . lineto (s, ms, ms);
		ctx . moveto (ss, 0, 0); ctx . lineto (s, 0, 0); ctx . lineto (s, ms, 0);
		ctx . moveto (ss, ms, ms); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (sss, s, 0); ctx . lineto (sss, s, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (s, 0, ms); ctx . lineto (s, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . stroke ();
	};
};

var Block5Z1 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, true], [false, false, false]],
					[[false, false, false], [true, true, true], [true, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, ms, ms); ctx . lineto (sss, ms, ms); ctx . lineto (sss, 0, ms);
		ctx . lineto (ss, 0, ms); ctx . lineto (ss, 0, 0); ctx . lineto (s, 0, 0); ctx . lineto (s, s, 0); ctx . lineto (0, s, 0);
		ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (sss, ms, s); ctx . lineto (sss, 0, s); ctx . lineto (s, 0, s);
		ctx . lineto (s, s, s); ctx . lineto (0, s, s); ctx . lineto (0, ms, s);
		ctx . moveto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, 0, 0);
		ctx . moveto (sss, ms, ms); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, ms); ctx . lineto (sss, 0, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (s, s, 0); ctx . lineto (s, s, s);
		ctx . moveto (0, s, 0); ctx . lineto (0, s, s);
		ctx . stroke ();
	};
};

var Block5Z2 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, true], [false, false, false]],
					[[true, false, false], [true, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, mss, 0); ctx . lineto (s, mss, 0); ctx . lineto (s, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, ms, ms);
		ctx . lineto (sss, ms, ms); ctx . lineto (sss, 0, ms); ctx . lineto (ss, 0, ms); ctx . lineto (ss, 0, 0);
		ctx . lineto (0, 0, 0); ctx . lineto (0, mss, 0);
		ctx . lineto (0, mss, s); ctx . lineto (s, mss, s); ctx . lineto (s, ms, s); ctx . lineto (sss, ms, s);
		ctx . lineto (sss, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, mss, s);
		ctx . moveto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, 0, 0);
		ctx . moveto (s, mss, 0); ctx . lineto (s, mss, s);
		ctx . moveto (s, ms, 0); ctx . lineto (s, ms, s);
		ctx . moveto (sss, ms, ms); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, ms); ctx . lineto (sss, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . stroke ();
	};
};

var Block5T = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, true], [true, true, true], [false, false, true]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, mss, 0); ctx . lineto (sss, mss, 0); ctx . lineto (sss, s, 0);
		ctx . lineto (ss, s, 0); ctx . lineto (ss, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, mss, s); ctx . lineto (sss, mss, s); ctx . lineto (sss, s, s);
		ctx . lineto (ss, s, s); ctx . lineto (ss, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (sss, mss, 0); ctx . lineto (sss, mss, s);
		ctx . moveto (sss, s, 0); ctx . lineto (sss, s, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . stroke ();
	};
};

var Block5F1 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[true, true, false], [true, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, mss, 0); ctx . lineto (ss, mss, 0); ctx . lineto (ss, ms, 0); ctx . lineto (sss, ms, 0);
		ctx . lineto (sss, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, mss, 0);
		ctx . lineto (0, mss, s); ctx . lineto (ss, mss, s); ctx . lineto (ss, ms, s); ctx . lineto (sss, ms, s);
		ctx . lineto (sss, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, mss, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . stroke ();
	};
};

var Block5F2 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, true, false], [false, false, false]],
					[[true, true, false], [true, true, false], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, mss, 0); ctx . lineto (ss, mss, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . lineto (s, 0, ms); ctx . lineto (s, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, mss, 0);
		ctx . lineto (0, mss, s); ctx . lineto (ss, mss, s); ctx . lineto (ss, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, mss, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (ss, 0, ms); ctx . lineto (ss, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (ss, ms, ms); ctx . lineto (s, ms, ms); ctx . lineto (s, 0, ms);
		ctx . moveto (ss, ms, 0); ctx . lineto (s, ms, 0); ctx . lineto (s, 0, 0);
		ctx . moveto (s, ms, ms); ctx . lineto (s, ms, 0);
		ctx . stroke ();
	};
};

var Block5BL = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[false, false, true], [false, false, true], [true, true, true]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, 0, 0); ctx . lineto (ss, 0, 0); ctx . lineto (ss, mss, 0); ctx . lineto (sss, mss, 0);
		ctx . lineto (sss, s, 0); ctx . lineto (0, s, 0); ctx . lineto (0, 0, 0);
		ctx . lineto (0, 0, s); ctx . lineto (ss, 0, s); ctx . lineto (ss, mss, s); ctx . lineto (sss, mss, s);
		ctx . lineto (sss, s, s); ctx . lineto (0, s, s); ctx . lineto (0, 0, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (sss, mss, 0); ctx . lineto (sss, mss, s);
		ctx . moveto (sss, s, 0); ctx . lineto (sss, s, s);
		ctx . moveto (0, s, 0); ctx . lineto (0, s, s);
		ctx . stroke ();
	};
};

var Block5L1 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, true]],
					[[false, false, false], [true, true, true], [false, false, true]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (sss, 0, 0); ctx . lineto (0, 0, 0);
		ctx . lineto (0, ms, 0); ctx . lineto (sss, ms, 0); ctx . lineto (sss, 0, 0); ctx . lineto (sss, 0, ms); ctx . lineto (sss, s, ms);
		ctx . lineto (ss, s, ms); ctx . lineto (ss, 0, ms); ctx . lineto (ss, 0, s);
		ctx . lineto (0, 0, s); ctx . lineto (0, ms, s); ctx . lineto (sss, ms, s);
		ctx . lineto (sss, s, s); ctx . lineto (ss, s, s); ctx . lineto (ss, 0, s);
		ctx . moveto (sss, 0, ms); ctx . lineto (ss, 0, ms);
		ctx . moveto (0, ms, 0); ctx . lineto (0, ms, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, s, ms); ctx . lineto (sss, s, s);
		ctx . moveto (ss, s, ms); ctx . lineto (ss, s, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . stroke ();
	};
};

var Block5L2 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, true], [false, false, false], [false, false, false]],
					[[false, false, true], [true, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (sss, ms, 0); ctx . lineto (0, ms, 0); ctx . lineto (0, 0, 0); ctx . lineto (sss, 0, 0); ctx . lineto (sss, ms, 0);
		ctx . lineto (sss, ms, ms); ctx . lineto (sss, mss, ms); ctx . lineto (ss, mss, ms); ctx . lineto (ss, ms, ms); ctx . lineto (ss, ms, s);
		ctx . lineto (0, ms, s); ctx . lineto (0, 0, s); ctx . lineto (sss, 0, s); ctx . lineto (sss, mss, s); ctx . lineto (ss, mss, s);
		ctx . lineto (ss, ms, s);
		ctx . moveto (ss, ms, ms); ctx . lineto (sss, ms, ms);
		ctx . moveto (ss, mss, ms); ctx . lineto (ss, mss, s);
		ctx . moveto (sss, mss, ms); ctx . lineto (sss, mss, s);
		ctx . moveto (sss, 0, 0); ctx . lineto (sss, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (0, ms, 0); ctx . lineto (0, ms, s);
		ctx . stroke ();
	};
};

var Block5M = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, false], [false, false, false]],
					[[true, true, false], [false, true, true], [false, false, true]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, mss, 0); ctx . lineto (ss, mss, 0); ctx . lineto (ss, ms, 0); ctx . lineto (sss, ms, 0); ctx . lineto (sss, s, 0);
		ctx . lineto (ss, s, 0); ctx . lineto (ss, 0, 0); ctx . lineto (s, 0, 0); ctx . lineto (s, ms, 0); ctx . lineto (0, ms, 0); ctx . lineto (0, mss, 0);
		ctx . lineto (0, mss, s); ctx . lineto (ss, mss, s); ctx . lineto (ss, ms, s); ctx . lineto (sss, ms, s); ctx . lineto (sss, s, s);
		ctx . lineto (ss, s, s); ctx . lineto (ss, 0, s); ctx . lineto (s, 0, s); ctx . lineto (s, ms, s); ctx . lineto (0, ms, s); ctx . lineto (0, mss, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, ms, s);
		ctx . moveto (sss, ms, 0); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, s, 0); ctx . lineto (sss, s, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, 0, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (s, ms, 0); ctx . lineto (s, ms, s);
		ctx . moveto (0, ms, 0); ctx . lineto (0, ms, s);
		ctx . stroke ();
	};
};

var Block5S3 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, true], [false, false, false]],
					[[true, true, false], [false, true, true], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (ss, 0, 0); ctx . lineto (ss, mss, 0); ctx . lineto (0, mss, 0);
		ctx . lineto (0, ms, 0); ctx . lineto (s, ms, 0); ctx . lineto (s, 0, 0); ctx . lineto (ss, 0, 0); ctx . lineto (ss, 0, ms);
		ctx . lineto (sss, 0, ms); ctx . lineto (sss, ms, ms); ctx . lineto (ss, ms, ms);
		ctx . lineto (ss, ms, s); ctx . lineto (ss, mss, s); ctx . lineto (0, mss, s);
		ctx . lineto (0, ms, s); ctx . lineto (s, ms, s); ctx . lineto (s, 0, s); ctx . lineto (sss, 0, s);
		ctx . lineto (sss, ms, s); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . moveto (sss, 0, ms); ctx . lineto (sss, 0, s);
		ctx . moveto (sss, ms, ms); ctx . lineto (sss, ms, s);
		ctx . moveto (ss, mss, 0); ctx . lineto (ss, mss, s);
		ctx . moveto (0, mss, 0); ctx . lineto (0, mss, s);
		ctx . moveto (0, ms, 0); ctx . lineto (0, ms, s);
		ctx . moveto (s, ms, 0); ctx . lineto (s, ms, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . stroke ();
	};
};

var Block5S4 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, false, true], [false, false, false]],
					[[false, false, false], [false, true, true], [true, true, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (ss, ms, 0); ctx . lineto (ss, s, 0); ctx . lineto (0, s, 0); ctx . lineto (0, 0, 0); ctx . lineto (s, 0, 0);
		ctx . lineto (s, ms, 0); ctx . lineto (ss, ms, 0); ctx . lineto (ss, ms, ms); ctx . lineto (sss, ms, ms);
		ctx . lineto (sss, 0, ms); ctx . lineto (ss, 0, ms);
		ctx . lineto (ss, 0, s); ctx . lineto (ss, s, s); ctx . lineto (0, s, s); ctx . lineto (0, 0, s); ctx . lineto (s, 0, s);
		ctx . lineto (s, ms, s); ctx . lineto (sss, ms, s); ctx . lineto (sss, 0, s); ctx . lineto (ss, 0, s);
		ctx . moveto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . moveto (sss, ms, ms); ctx . lineto (sss, ms, s);
		ctx . moveto (sss, 0, ms); ctx . lineto (sss, 0, s);
		ctx . moveto (ss, s, 0); ctx . lineto (ss, s, s);
		ctx . moveto (0, s, 0); ctx . lineto (0, s, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (s, 0, 0); ctx . lineto (s, 0, s);
		ctx . moveto (s, ms, 0); ctx . lineto (s, ms, s);
		ctx . stroke ();
	};
};

var Block5SP1 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, true, false], [false, true, true]],
					[[false, false, false], [true, true, false], [false, false, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, ms, 0); ctx . lineto (s, ms, 0); ctx . lineto (s, ms, ms); ctx . lineto (ss, ms, ms); ctx . lineto (ss, 0, ms);
		ctx . lineto (sss, 0, ms); ctx . lineto (sss, s, ms); ctx . lineto (s, s, ms); ctx . lineto (s, s, 0); ctx . lineto (sss, s, 0);
		ctx . lineto (sss, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, ms, 0);
		ctx . lineto (0, ms, s); ctx . lineto (ss, ms, s); ctx . lineto (ss, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, ms, s);
		ctx . moveto (s, ms, ms); ctx . lineto (s, s, ms);
		ctx . moveto (s, ms, 0); ctx . lineto (s, s, 0);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (ss, ms, ms); ctx . lineto (ss, ms, s);
		ctx . moveto (ss, 0, ms); ctx . lineto (ss, 0, s);
		ctx . moveto (sss, 0, ms); ctx . lineto (sss, 0, 0);
		ctx . moveto (sss, s, ms); ctx . lineto (sss, s, 0);
		ctx . stroke ();
	};
};

var Block5SP2 = function () {
	Block . call (this);
	this . score = 5;
	this . block = [[[false, false, false], [false, true, true], [false, true, false]],
					[[false, false, false], [false, false, false], [true, true, false]],
					[[false, false, false], [false, false, false], [false, false, false]]];
	this . draw = function (ctx, dims) {
		var s = dims . side, ms = -s, mss = ms - s, ss = s + s, sss = ss + s;
		ctx . beginPath ();
		ctx . moveto (0, s, 0); ctx . lineto (s, s, 0); ctx . lineto (s, s, ms); ctx . lineto (ss, s, ms); ctx . lineto (ss, 0, ms);
		ctx . lineto (sss, 0, ms); ctx . lineto (sss, ms, ms); ctx . lineto (s, ms, ms); ctx . lineto (s, ms, 0); ctx . lineto (sss, ms, 0);
		ctx . lineto (sss, 0, 0); ctx . lineto (0, 0, 0); ctx . lineto (0, s, 0);
		ctx . lineto (0, s, s); ctx . lineto (ss, s, s); ctx . lineto (ss, 0, s); ctx . lineto (0, 0, s); ctx . lineto (0, s, s);
		ctx . moveto (s, ms, ms); ctx . lineto (s, s, ms);
		ctx . moveto (s, ms, 0); ctx . lineto (s, s, 0);
		ctx . moveto (ss, s, ms); ctx . lineto (ss, s, s);
		ctx . moveto (ss, 0, ms); ctx . lineto (ss, 0, s);
		ctx . moveto (0, 0, 0); ctx . lineto (0, 0, s);
		ctx . moveto (sss, ms, ms); ctx . lineto (sss, ms, 0);
		ctx . moveto (sss, 0, ms); ctx . lineto (sss, 0, 0);
		ctx . stroke ();
	};
};

var blocks_2 = [Block1, Block2];
var blocks_32 = [Block1, Block2, Block32];
var blocks_3 = [Block1, Block2, Block31, Block32];
var blocks_4 = [Block1, Block2, Block31, Block32, Block41, Block42, Block43, Block44, Block45, Block46, Block47];

var all_blocks = [Block1, Block2, Block31, Block32, Block41, Block42, Block43, Block44, Block45, Block46, Block47,
			Block51, Block52, Block53, Block5Z, Block5Z1, Block5Z2, Block5P, Block5E, Block5LL,
			Block5S1, Block5S2, Block5S3, Block5S4,
			Block5T, Block5F1, Block5F2, Block5BL, Block5L1, Block5L2, Block5M,
			Block54];

var blocks = [Block1, Block2, Block31, Block32, Block41, Block42, Block43, Block44, Block45, Block46, Block47,
			Block51, Block52, Block53, Block5Z, Block5Z1, Block5Z2, Block5P, Block5E, Block5LL,
			Block5S1, Block5S2, Block5S3, Block5S4,
			Block5T, Block5F1, Block5F2, Block5BL, Block5L1, Block5L2, Block5M,
			Block54, Block5SP1];

var block_matrix = {blocks_2: blocks_2, blocks_32: blocks_32, blocks_3: blocks_3, blocks_4: blocks_4, all_blocks: all_blocks, default: all_blocks};

var block = null;
var block_number = 0;

var chooseBlock = function (blocks, id) {
	if (id != undefined) block_number = id;
	else block_number = Math . floor (Math . random () * blocks . length);
	var constructor = blocks [block_number];
	if (constructor == undefined) constructor = Block1;
	block = new constructor ();
//	block = new Block5SP2 ();
	block . readjust_position (well);
};

var Well = function (setup) {
	this . score = 0;
	this . random_area = 3;
	this . random_blocks = 32;
	this . addScore = function (score) {this . score += score;};
	this . save_game = 'save_game';
	this . save_scores = 'scores';
	this . id = 'default';
	this . dimensions = {width: 7, height: 7, depth: 12, side: 40};
	this . colours = ['blue', 'red', 'magenta', 'green', 'cyan', 'yellow', 'gray', 'orange', 'silver', 'maroon', 'lime', 'olive', 'aqua', 'fuchsia', 'teal', 'navy', 'purple'];
	this . content = [];
	this . initialiseContent = function () {
		this . content = [];
		for (var z = 0; z < this . dimensions . depth; z++) {
			var layer = []; this . content . push (layer);
			for (var x = 0; x < this . dimensions . width; x++) {
				var column = []; layer . push (column);
				for (var y = 0; y < this . dimensions . height; y++) {
					column . push (false);
				}
			}
		}
	};
	this . addBlock = function (x, y) {
		if (this . content [0] [x] [y]) return false;
		for (var depth = 0; depth < this . dimensions . depth - 1; depth++) {
			if (this . content [depth + 1] [x] [y] && ! this . content [depth] [x] [y]) return this . content [depth] [x] [y] = true;
		}
		return this . content [this . dimensions . depth - 1] [x] [y] = true;
	};
	this . level = function (x, y) {
		if (x < 0 || y < y || x >= this . dimensions . width || y >= this . dimensions . height) return 16384;
		for (var depth = 0; depth < this . dimensions . depth; depth++) {
			if (this . content [depth] [x] [y]) return depth - 1;
		}
		return this . dimensions . depth - 1;
	};
	this . insertRandomBlock = function () {
		this . content [Math . floor ((this . dimensions . depth - this . random_area) * Math . random ()) + this . random_area]
						[Math . floor (this . dimensions . width * Math . random ())]
						[Math . floor (this . dimensions . height * Math . random ())] = true;
	};
	this . reSide = function (width, height) {
		this . dimensions . side = Math . min (width / this . dimensions . width * 0.96, height / this . dimensions . height * 0.96);
	};
	this . removeLayer = function (depth) {
		while (depth > 0) {
			var next = depth - 1;
			for (var x = 0; x < this . dimensions . width; x++) {
				for (var y = 0; y < this . dimensions . height; y++) {
					this . content [depth] [x] [y] = this . content [next] [x] [y];
				}
			}
			depth = next;
		}
		for (var x = 0; x < this . dimensions . width; x++) {
			for (var y = 0; y < this . dimensions . height; y++) this . content [0] [x] [y] = false;
		}
	};
	this . reduceLevel = function () {
		for (var depth = 0; depth < this . dimensions . depth; depth++) {
			var full = true;
			for (var x = 0; full && x < this . dimensions . width; x++) {
				for (var y = 0; full && y < this . dimensions . height; y++) full = full & this . content [depth] [x] [y];
			}
			if (full) {
				//alert (`Full level at ${depth}`);
				this . removeLayer (depth);
				return true;
			}
		}
		return false;
	};
	this . freeLevels = function () {
		for (var depth = 0; depth < this . dimensions . depth; depth++) {
			for (var x = 0; x < this . dimensions . width; x++) {
				for (var y = 0; y < this . dimensions . height; y++) {
					if (this . content [depth] [x] [y]) return depth;
				}
			}
		}
		return this . dimensions . depth;
	};
	this . completed = function () {return this . freeLevels () >= this . dimensions . depth - 1;};
	this . drawWell = function (ctx) {
		ctx . beginPath ();
		var right = this . dimensions . width * 0.5 * this . dimensions . side, left = - right;
		var bottom = this . dimensions . height * 0.5 * this . dimensions . side, top = - bottom;
		var depth = this . dimensions . depth * this . dimensions . side;
		for (var y = 1; y < this . dimensions . height; y++) {
			var yy = top + this . dimensions . side * y;
			ctx . moveto (left, yy, 0); ctx . lineto (left, yy, depth); ctx . lineto (right, yy, depth); ctx . lineto (right, yy, 0);
		}
		for (var x = 1; x < this . dimensions . width; x++) {
			var xx = left + this . dimensions . side * x;
			ctx . moveto (xx, top, 0); ctx . lineto (xx, top, depth); ctx . lineto (xx, bottom, depth); ctx . lineto (xx, bottom, 0);
		}
		for (var z = 0; z <= this . dimensions . depth; z++) {
			var zz = this . dimensions . side * z;
			ctx . moveto (left, top, zz); ctx . lineto (right, top, zz); ctx . lineto (right, bottom, zz);
			ctx . lineto (left, bottom, zz); ctx . lineto (left, top, zz);
		}
		ctx . moveto (left, top, 0); ctx . lineto (left, top, depth);
		ctx . moveto (right, top, 0); ctx . lineto (right, top, depth);
		ctx . moveto (right, bottom, 0); ctx . lineto (right, bottom, depth);
		ctx . moveto (left, bottom, 0); ctx . lineto (left, bottom, depth);
		ctx . stroke ();
	};
	this . drawContent = function (ctx) {
		var side = this . dimensions . side;
		var left = -0.5 * this . dimensions . width * side;
		var top = 0.5 * this . dimensions . height * side;
		for (var layer = this . dimensions . depth - 1; layer >= 0; layer--) {
			ctx . fillStyle = this . colours [layer];
			var depth = layer * side;
			for (var x = 0; x < this . dimensions . width; x++) {
				for (var y = 0; y < this . dimensions . height; y++) {
					if (this . content [layer] [x] [y]) {
						var a = left + side * x, b = a + side, c = top - side * y - side, d = c + side, dd = depth + side;
						ctx . beginPath ();
						ctx . moveto (a, c, depth), ctx . lineto (b, c, depth); ctx . lineto (b, d, depth); ctx . lineto (a, d, depth), ctx . closePath ();
						ctx . fill ();
						ctx . stroke ();
						if (y + 1 < this . dimensions . height * 0.5) {
							ctx . beginPath ();
							ctx . moveto (a, c, depth), ctx . lineto (a, c, dd); ctx . lineto (b, c, dd); ctx . lineto (b, c, depth);
							ctx . fill ();
						}
						if (y > this . dimensions . height * 0.5) {
							ctx . beginPath ();
							ctx . moveto (b, d, depth), ctx . lineto (b, d, dd); ctx . lineto (a, d, dd); ctx . lineto (a, d, depth);
							ctx . fill ();
						}
						if (x > this . dimensions . width * 0.5) {
							ctx . beginPath ();
							ctx . moveto (a, c, depth), ctx . lineto (a, c, dd); ctx . lineto (a, d, dd); ctx . lineto (a, d, depth);
							ctx . fill ();
						}
						if (x + 1 < this . dimensions . width * 0.5) {
							ctx . beginPath ();
							ctx . moveto (b, c, depth), ctx . lineto (b, c, dd); ctx . lineto (b, d, dd); ctx . lineto (b, d, depth);
							ctx . fill ();
						}
					}
				}
			}
		}
	};
	this . draw = function (ctx, width, height) {
		ctx . clearRect (0, 0, width, height);
		ctx . strokeStyle = '#44ff44';
		ctx . resetTransform ();
		ctx . lineWidth = 1;
		ctx . translate (width * 0.5, height * 0.5);
		this . drawWell (ctx);
		this . drawContent (ctx);
	}
	for (var key in setup) {
		if (typeof setup [key] == 'object') {for (var sub in setup [key]) this [key] [sub] = setup [key] [sub];}
		else this [key] = setup [key];
	}
	this . initialiseContent ();
	for (var ind = 0; ind < this . random_blocks; ind++) this . insertRandomBlock ();
	if (this . dimensions . depth > this . colours . length) this . dimensions . depth = this . colours . length;
	if (this . random_area > this . dimensions . depth) this . random_area = this . dimensions . depth;
};

var well = new Well (setup);

chooseBlock (blocks);

var drawHiScores = function (dims) {
	var entry = localStorage . getItem ([well . save_scores, well . id, dims . depth, dims . width, dims . height]);
	if (entry != undefined) entry = JSON . parse (entry);
	else {
		entry = [];
		for (var ind = 0; ind < 10; ind++) entry . push ({name: '---', score: '---'});
		localStorage . setItem ([well . save_scores, well . id, dims . depth, dims . width, dims . height], JSON . stringify (entry));
	}
	for (var ind = 0; ind < 10; ind++) {
		document . getElementById ('name_' + ind) . innerHTML = entry [ind] . name;
		document . getElementById ('score_' + ind) . innerHTML = entry [ind] . score;
	}
};

var enterScore = function (dims, name, score) {
	var entry = localStorage . getItem ([well . save_scores, well . id, dims . depth, dims . width, dims . height]);
	if (entry != undefined) entry = JSON . parse (entry);
	entry . unshift ({name: name, score: score});
	entry . sort (function (a, b) {return a . score > b . score;});
	localStorage . setItem ([well . save_scores, well . id, dims . depth, dims . width, dims . height], JSON . stringify (entry));
};

var saveGame = function () {
	var payload = {block_number: block_number, score: well . score, content: well . content};
	payload = JSON . stringify (payload);
	localStorage . setItem ([well . save_game, well . id, well . dimensions . depth, well . dimensions . width, well . dimensions . height], payload);
};

var loadGame = function () {
	var payload = localStorage . getItem ([well . save_game, well . id, well . dimensions . depth, well . dimensions . width, well . dimensions . height]);
	if (payload == undefined) return;
	payload = JSON . parse (payload);
	chooseBlock (blocks, payload . block_number);
	well . score = payload . score;
	well . content = payload . content;
};

var resize = function () {
	canvas . width = window . innerWidth;
	canvas . height = window . innerHeight;
	well . reSide (window . innerWidth, window . innerHeight);
	well . draw (ctx, window . innerWidth, window . innerHeight);
	if (well . completed ()) {
		var name = prompt ("Mission Accomplished\nYour name", "name");
		if (name != null) enterScore (well . dimensions, name, well . score);
		block = null;
		localStorage . removeItem ([well . save_game, well . id, well . dimensions . depth, well . dimensions . width, well . dimensions . height]);
	}
	if (block == null) {
		ctx . strokeStyle = 'red';
		ctx . strokeText ("GAME OVER", 0, 0);
		ctx . strokeText ("Press ENTER or RELEASE (spacebar) to start new game.", -100, 20);
		drawHiScores (well . dimensions);
	} else {
		ctx . strokeStyle = 'white'; ctx . lineWidth = 3; ctx . lineCap = 'round';
		block . drawer (ctx, well . dimensions);
	}
};
/*
for (var d = 0; d < well . dimensions . depth; d++) {
	for (var x = 0; x < well . dimensions . width; x++) {
		for (var y = 0; y < well . dimensions . height; y++) {
			well . content [d] [x] [y] = d >= well . dimensions . depth - 2;
		}
	}
}
*/
//block . readjust_position (well);
loadGame ();
document . getElementById ('score') . innerHTML = 'SCORE = ' + well . score;
drawHiScores (well . dimensions);
resize ();

var sin1 = Math . sin (Math . PI * 0.125);
var cos1 = Math . cos (Math . PI * 0.125);

var animate_roll = function (block, well) {
};

var ctrl = function (key) {
	if (block == null) {if (key != "enter" && key != " ") return; well = new Well (setup); chooseBlock (blocks); resize (); return;}
	switch (key) {
	case "arrowright": block . move_right (well . dimensions); break;
	case "arrowleft": block . move_left (well . dimensions); break;
	case "arrowup": block . move_up (well . dimensions); break;
	case "arrowdown": block . move_down (well . dimensions); break;
	case "f":
//	this . rotate = function (matrix, dimensions) {this . rotation = mtm (this . rotation, matrix); this . clamp (dimensions, this . rotate_block ());};
		setTimeout (function () {
			var m = block . rotation;
			block . rotation = mtm (block . rotation, [[cos1, - sin1, 0, 0], [sin1, cos1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]);
			resize ();
			setTimeout (function () {
				block . rotation = mtm (block . rotation, [[cos1, - sin1, 0, 0], [sin1, cos1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]);
				resize ();
				setTimeout (function () {
					block . rotation = mtm (block . rotation, [[cos1, - sin1, 0, 0], [sin1, cos1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]);
					resize ();
					setTimeout (function () {
						block . rotation = mtm (m, [[0, -1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]);
						block . clamp (well . dimensions, block . rotate_block ());
						resize ();
					}, 150);
				}, 150);
			}, 150);
		}, 150);
		break;
	case "d": block . rotate ([[0, -1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "e": block . rotate ([[0, 1, 0, 0], [-1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "q": block . rotate ([[1, 0, 0, 0], [0, 0, -1, 0], [0, 1, 0, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "a": block . rotate ([[1, 0, 0, 0], [0, 0, 1, 0], [0, -1, 0, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "w": block . rotate ([[0, 0, -1, 0], [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1]], well . dimensions); break;
	case "s": block . rotate ([[0, 0, 1, 0], [0, 1, 0, 0], [-1, 0, 0, 0], [0, 0, 0, 1]], well . dimensions); break;
	case " ":
		if (block . addToWell (well)) {block = null; break;}
		setTimeout (function () {while (well . reduceLevel ()) resize ();}, 1000);
		chooseBlock (blocks);
		document . getElementById ('score') . innerHTML = 'SCORE = ' + well . score;
		break;
	case "enter": block . level (well); break;
	default: break;
	}
	resize ();
	saveGame ();
};

</script>


</html>

